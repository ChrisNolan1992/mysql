/**
 * mio-mysql
 *
 * MySQL storage plugin for Mio.
 *
 * @author Alex Mingoia <talk@alexmingoia.com>
 * @link https://github.com/alexmingoia/mio-mysql
 */

var async    = require('async')
  , debug    = require('debug')('mio-mysql')
  , mio      = require('mio')
  , lingo    = require('lingo').en
  , mosql    = require('mongo-sql')
  , mysql    = require('mysql');

module.exports = plugin;

/**
 * Expose `mysql` module. If you want to access the Model's database
 * connection, use `Model.options.mysql.pool`.
 */

module.exports.mysql = mysql;

var store = module.exports.store = {};

/**
 * Initialize a new MySQL plugin with given `settings`.
 *
 * options
 *     - maxLimit  Maximum size of query limit parameter (Default: 200).
 *     - tableName MySQL table name for this Model.
 *
 * @param {Object} settings database settings for github.com/felixge/node-mysql
 * @param {Object} options options for this plugin instance
 * @return {Function}
 * @api public
 */

function plugin(settings, options) {
  return function(Model) {
    // Models share connection pool through shared settings object
    if (!settings.pool) {
      settings.queryTimeout = settings.queryTimeout || 60000;

      settings.db = settings.pool = mysql.createPool(settings);

      settings.pool.on('connection', function(conn) {
        debug('connected to %s', settings.host);

        conn.on('error', function(err) {
          debug('connection error', err);

          // destroy connection on error
          debug('disconnected from %s', settings.host);
          conn.destroy();

          Model.emit('mysql error', err);
          Model.emit('error', err);
        });

        // Enable ANSI_QUOTES for compatibility with queries generated by
        // mongo-sql.
        conn.query('SET SESSION sql_mode=ANSI_QUOTES');
      });
    }

    Model.options.mysql = settings;

    if (!Model.options.mysql.tableName) {
      Model.options.mysql.tableName = lingo.singularize(Model.type.toLowerCase());
    }

    Model
      .use('findAll', store.findAll)
      .use('count', store.count)
      .use('find', store.find)
      .use('save', store.save)
      .use('remove', store.remove);
  };
};

/**
 * Find all models with given `query`.
 *
 * @param {Object} query
 * @param {Function(err, collection)} callback
 * @api public
 */

store.findAll = function(query, callback) {
  var Model = this;
  var pool = Model.options.mysql.pool;

  var limit = Number(query.pageSize || query.limit || 50);
  var offset = Number(query.page ? (query.page * limit) - limit : query.offset || 0);
  if (limit > this.options.maxLimit) {
    limit = this.options.maxLimit;
  }

  var collection = [];
  collection.offset = offset;
  collection.limit = limit;
  collection.page = Math.ceil((offset + limit) / limit) || 1;
  collection.pageSize = limit;
  collection.total = 0;
  collection.toJSON = collectionToJSON;

  async.waterfall([
    function(next) {
      debug('dispensing connection from pool');

      pool.getConnection(function(err, conn) {
        if (err) return next(err);
        next(null, conn);
      });
    },
    function(conn, next) {
      var sql = store.queryToSQL(Model, merge(merge({
        type: 'select',
        groupBy: [ Model.options.mysql.tableName + '.' + Model.primaryKey ],
        columns: [
          { name: Model.primaryKey, table: Model.options.mysql.tableName }
        ],
        table: Model.options.mysql.tableName,
      }, query), { offset: null, limit: null }));
      store.query(Model, sql.query, sql.values, function(err, rows, fields, conn) {
        if (err) return next(err);
        var ids = [];
        collection.total = rows.length;
        collection.pages = Math.ceil(collection.total / collection.pageSize);
        for (var i=0; i<limit; i++) {
          if (stripTableName(rows[offset + i], Model).id) {
            ids.push(stripTableName(rows[offset + i], Model).id);
          }
        }
        next(null, ids, conn);
      }, conn);
    },
    function(ids, conn, next) {
      if (!ids.length) return next(null, conn);
      var idQuery = merge({
        type: 'select',
        columns: [
          { name: '*', table: Model.options.mysql.tableName }
        ],
        table: Model.options.mysql.tableName
      }, { offset: null, limit: null });
      idQuery[Model.primaryKey] = { $in: ids };
      var sql = store.queryToSQL(Model, idQuery);
      store.query(Model, sql.query, sql.values, function(err, rows, fields, conn) {
        if (err) return next(err);
        if (!rows || !rows.length) return next(null, conn);

        for (var len = rows.length, i=0; i<len; i++) {
          collection.push(new Model(stripTableName(rows[i], Model)));
        }

        next(null, conn);
      }, conn);
    }
  ],
  function(err, conn) {
    if (err) return callback(err);

    debug('returning connection to pool');
    conn.release();

    callback(null, collection);
  });
};

/**
 * Count models with given `query`.
 *
 * @param {Object} query
 * @param {Function(err, model)} callback
 * @api public
 */

store.count = function(query, callback) {
  var sql = store.queryToSQL(this, merge({
    type: 'select',
    columns: [ 'COUNT(*) as _count' ],
    table: this.options.mysql.tableName
  }, query));

  store.query(this, sql.query, sql.values, function(err, rows) {
    if (err) return callback(err);
    if (!rows || !rows.length) return callback(null, 0);
    callback(null, rows[0].__count || 0);
  });
};

/**
 * Find model with given `id`.
 *
 * @param {Number|Object} id or query
 * @param {Function(err, model)} callback
 * @api public
 */

store.find = function(id, callback) {
  var Model = this;

  var query = typeof id == 'object' ? id : { where: { id: id } };

  var sql = store.queryToSQL(this, merge({
    type: 'select',
    columns: [
      { name: '*', table: this.options.mysql.tableName }
    ],
    table: this.options.mysql.tableName
  }, query));

  store.query(this, sql.query, sql.values, function(err, rows) {
    if (err) return callback(err);
    if (!rows || !rows.length) return callback();

    var model = new Model(stripTableName(rows[0], this));

    callback(null, model);
  });
};

/**
 * Save.
 *
 * @param {Object} changed
 * @param {Function(err, attributes)} done
 * @api private
 */

store.save = function(changed, done) {
  var Model = this.constructor;
  var model = this;

  if (this.primary && !changed[Model.primaryKey]) {
    return store.update.call(this, changed, done);
  }

  var sql = store.queryToSQL(Model, {
    type: 'insert',
    table: Model.options.mysql.tableName,
    values: changed
  });

  store.query(Model, sql.query, sql.values, function(err, rows) {
    if (err) return done(err);

    if (rows.insertId) {
      model[Model.primaryKey] = rows.insertId;
    }

    done();
  });
};

/**
 * Update.
 *
 * @param {Object} changed
 * @param {Function(err, attributes)} done
 * @api private
 */

store.update = function(changed, done) {
  var Model = this.constructor;

  var where = {};
  where[Model.primaryKey] = this.primary;

  var sql = store.queryToSQL(Model, {
    type: 'update',
    table: Model.options.mysql.tableName,
    where: where,
    values: changed
  });

  store.query(Model, sql.query, sql.values, function(err, rows, fields) {
    if (err) return done(err);
    done();
  });
};

/**
 * Remove.
 *
 * @param {Function(err)} done
 * @api private
 */

store.remove = function(done) {
  var Model = this.constructor;

  var query = {
    type: 'delete',
    table: Model.options.mysql.tableName,
    where: {}
  };
  query.where[Model.primaryKey] = this.primary;

  var sql = store.queryToSQL(Model, query);

  store.query(Model, sql.query, sql.values, function(err, rows) {
    if (err) return done(err);
    done();
  });
};

/**
 * Wrapper for `mysql.query`. Transforms results and retries on deadlock.
 */

store.query = function(Model, statement, values, callback, existingConn) {
  var pool = Model.options.mysql.pool;

  // node-mysql uses `?` whereas mongo-sql uses `$1, $2, $3...`,
  // so we have to implement our own query formatter assigned
  // when extending the model class.
  var sql = mysql.format(
    (statement.sql || statement).replace(/\$\d+/g, '?'),
    values
  );

  if (existingConn) {
    query(null, existingConn);
  }
  else {
    debug('dispensing connection from pool');
    pool.getConnection(query);
  }

  function query(err, conn) {
    if (err) return callback(err);

    // Called when we are finished with the query.
    function done(err, rows, fields) {
      clearTimeout(timer);

      debug("%s", sql);

      // return connection to pool, or destroy if canceled
      if (conn.canceled) {
        debug('destroying canceled connection');
        conn.destroy();
      }
      else if (!existingConn) {
        debug('returning connection to pool');
        conn.release();
      }

      if (err) return callback(err);

      if (rows && rows.length) {
        rows.forEach(function(row, i) {
          // Transform names using attribute definition's .columnName property
          rows[i] = transformRowColumns(row, Model, !!statement.nestTables);
          // Format row values
          formatRowValues(rows[i], Model, !!statement.nestTables);
        });
      }

      // original query callback
      callback.call(Model, null, rows, fields, conn);
    };


    // Query timeout
    var timer = setTimeout(function() {
      conn.canceled = true;
      done(new Error("Connection ended due to query time-out."));
    }, Model.options.mysql.queryTimeout);

    // Nest (prefix with table name) tables by default.
    if (typeof statement === 'string') {
      statement = { sql: sql, nestTables: '_' }
    }

    conn.query({
      sql: sql,
      nestTables: statement.nestTables
    }, function(err, rows, fields) {
      if (conn.canceled) return;

      // Re-try query on DEADLOCK error
      if (err && ~err.message.indexOf('DEADLOCK')) {
        debug('deadlock encountered');

        return (function retry() {
          var attemptCount = 0;

          (function attempt() {
            debug('retrying deadlocked query');
            attemptCount++;

            conn.query(sql, function(err, rows, fields) {
              if (err) {
                if (attemptCount > 3) return done(err);
                if (~err.message.indexOf('DEADLOCK')) return attempt();
                return done(err);
              }
              done(null, rows, fields);
            });
          })();
        })();
      }

      done(err, rows, fields);
    });
  };
};

var queryKeywords = [
  'distinct',
  'updates',
  'joins',
  'columns',
  'table',
  'values',
  'where',
  'offset',
  'limit',
  'sort',
  'order',
  'page',
  'pageSize',
  'type',
  'groupBy'
];

/**
 * Process deserialized request query and return mongo-sql object.
 *
 * @link https://github.com/goodybag/mongo-sql/
 * @param {AbstractModel} Model
 * @param {Object} query
 * @return {mosql.sql}
 * @api private
 */

store.queryToSQL = function(Model, query) {
  // Don't modify original query
  query = JSON.parse(JSON.stringify(query));

  if (!query.type) {
    query.type = 'select';
  }

  // Merge top-level parameters into `query.where`
  for (var param in query) {
    if (!~queryKeywords.indexOf(param)) {
      query.where = query.where || {};
      query.where[param] = query[param];
      delete query[param];
    }
  }

  // `query.sort` is alias for `query.order`
  if (query.sort) {
    query.order = query.sort;
    delete query.sort;
  }

  formatQueryValues(query, Model);

  transformQueryColumns(query, Model);

  return mosql.sql(query);
};

/**
 * Transform query attribute names to column names.
 */

function transformQueryColumns(query, Model, attrName) {
  var attributes = Model.attributes;
  for (var key in query) {
    var attr = attributes[key];
    // Found attribute.. transform
    if (attr && attr.columnName) {
      query[attr.columnName] = query[key];
      delete query[key];
    }
    // Recurse objects/arrays
    if (typeof query[key] === 'object') {
      transformQueryColumns(query[key], Model);
    }
  }
};

/**
 * Format query values
 */

function formatQueryValues(query, Model, needle) {
  if (!query) return;

  for (var key in query) {
    var attr = Model.attributes[needle || key];
    var val = query[key];

    if (!needle && attr && attr.dataFormatter) {
      query[key] = attr.dataFormatter(val, Model);
      continue;
    }

    var attrType = attr ? (attr.type || attr.format) : attr;
    var columnType = attr ? attr.columnType : attr;
    var queryType = typeof val;

    switch (attrType) {
      case 'date':
        if (queryType != 'object') {
          if (queryType == 'boolean') break;
          val = String(val);
          if (isNaN(val)) {
            if (!isNaN(val.substr(0, 4))) {
              val = new Date(val);
            }
          }
          else {
            if (val.length === 4 || val.length > 10) {
              val = new Date(val);
            }
            else if (val.length === 10) {
              val = new Date(val * 1000);
            }
          }
        }
        if (val.toISOString) {
          switch (attr.columnType) {
            case 'datetime':
              val = val.toISOString();
              break;
            case 'timestamp':
              var d = val;
              val = d.getFullYear() + '-' + pad(d.getMonth()) + '-'
                + pad(d.getDate()) + ' ' + pad(d.getHours()) + ':'
                + pad(d.getMinutes()) + ':' + pad(d.getSeconds());
              break;
            case 'integer':
            case 'number':
            default:
              val = Math.floor(val.valueOf() / 1000);
          }
        }
        else {
          formatQueryValues(val, Model, needle || key);
        }
        break;
      case 'array':
      case 'object':
      case 'json':
        val = JSON.stringify(val);
        break;
      case 'uuid':
        if (queryType === 'object') {
          formatQueryValues(val, Model, needle || key);
        }
        else if (val) {
          val = new Buffer(val.replace(/-/g, ''), 'hex');
        }
        break;
      default:
        if (queryType === 'object') {
          formatQueryValues(val, Model);
        }
        else if (attrType === 'boolean' && queryType.match(/(boolean|string)/)) {
          val = val === true || val === 'true' ? 1 : 0;
          if (columnType === 'set') {
            val = val ? '1' : '';
          }
        }
    }
    query[key] = val;
  }
};

/**
 * Format row values
 */

function formatRowValues(row, Model, prefix) {
  prefix = prefix ? Model.options.mysql.tableName + '_' : '';

  for (var key in row) {
    var attr = Model.attributes[key.replace(prefix, '')];
    var val = row[key];
    var type = attr ? (attr.type || attr.format) : attr;

    // Transform boolean values
    if (type == 'boolean') {
      row[key] = Boolean(val);
    }

    // Transfoorm date values
    if (type == 'date' && (typeof val == 'string' || typeof val == 'number')) {
      row[key] = new Date(isNaN(val) ? val : val * 1000);
    }

    // Transform binary UUID back to hex string
    if (type == 'uuid' && (val instanceof Buffer)) {
      var uuid = val.toString('hex');

      // add dashes to UUID such that 110E8400E29B11D4A716446655440000
      // becomes 110E8400-E29B-11D4-A716-446655440000
      uuid = uuid.split('');
      [8, 13, 18, 23].forEach(function(pos) {
        uuid.splice(pos, 0, '-');
      });

      row[key] = uuid.join('');
    }
  }
};

/**
 * Transform column names in mysql result row to attribute names using
 * the `Model.attributes[attr].columnName` property.
 */

function transformRowColumns(row, Model, prefix) {
  prefix = prefix ? Model.options.mysql.tableName + '_' : '';
  var converted = {};
  columnsToAttributes = {};
  for (var key in Model.attributes) {
    if (Model.attributes[key].columnName) {
      columnsToAttributes[Model.attributes[key].columnName] = key;
    }
  }
  for (var key in row) {
    var attr = key;
    if (key.indexOf(prefix) === 0) {
      attr = key.replace(prefix, '');
    }
    if (columnsToAttributes[attr]) {
      converted[prefix + columnsToAttributes[attr]] = row[key];
      delete converted[key];
    }
    else {
      converted[key] = row[key];
    }
  }
  return converted;
};

/**
 * Format collection for JSON transport.
 */

function collectionToJSON() {
  var collection = [];

  for (var len = this.length, i=0; i<len; i++) {
    collection[i] = this[i];
  }

  return {
    collection: collection,
    offset:     this.offset,
    limit:      this.limit,
    page:       this.page,
    pages:      this.pages,
    pageSize:   this.pageSize,
    total:      this.total
  };
};

/**
 * Strip given `table_` prefix from attribute names.
 */

function stripTableName(attrs, Model) {
  var table = Model.options.mysql.tableName;

  var stripped = {};

  for (var attr in attrs) {
    if (attr.indexOf(table + '_') === 0 || attr == '_count') {
      stripped[attr.replace(table + '_', '')] = attrs[attr];
    }
  }

  return stripped;
};

/**
 * Pad number with leading 0
 */

function pad(num) {
  num = String(num);
  if (num.length == 1) {
    num = '0' + num;
  }
  return num;
};

/**
 * Merge properties from `b` into `a`.
 */

function merge(a, b) {
  for (var key in b) {
    a[key] = b[key];
  }
  return a;
};
